<input
                              className={`form-control ${
                                errors?.components?.[index]?.date_of_joining
                                  ? "is-invalid"
                                  : ""
                              }`}
                              type="date"
                              id={`date_of_joining-${index}`}
                              {...register(
                                `components[${index}].date_of_joining`,
                                {
                                  required: "Date of Joining is required",
                                  validate: (value) => {
                                    const today = new Date()
                                      .toISOString()
                                      .split("T")[0];
                                    if (!value) {
                                      return "Date of Joining is required";
                                    } else if (value > today) {
                                      return "Date of Joining cannot be in the future";
                                    }
                                    return true;
                                  },
                                }
                              )}
                            />



const isValid = await trigger();
    if (!isValid) {
      toast.error("Validation failed");
      console.log(errors);

      return;
    }








  // import { createTransform } from "redux-persist";
// import CryptoJS from "crypto-js";

// const SECRET_KEY = process.env.REACT_APP_cryptography_key;
// console.log(`SECRET_KEY: ${SECRET_KEY}`)

// const ciperText = createTransform(
//   (inboundState) => {

//     try {
//       const stringifiedState = JSON.stringify(inboundState);
//       return CryptoJS.AES.encrypt(stringifiedState, SECRET_KEY).toString();
//     } catch (error) {
//       console.error("Error encrypting state", error);
//       return inboundState;
//     }
//   },
//   (outboundState) => {
//     try {
//       const bytes = CryptoJS.AES.decrypt(outboundState, SECRET_KEY);
//       const decryptedState = bytes.toString(CryptoJS.enc.Utf8);
//       return JSON.parse(decryptedState);
//     } catch (error) {
//       console.error("Error decrypting state", error);
//       return outboundState;
//     }
//   }
// );

// export default ciperText;

import { createTransform } from "redux-persist";
import CryptoJS from "crypto-js";

const SECRET_KEY = process.env.REACT_APP_cryptography_key;
let cachedIpAddress = Date.now();

// Function to fetch the IP address and cache it
const fetchIpAddress = async () => {
  if (cachedIpAddress) return cachedIpAddress;

  try {
    const response = await fetch("https://api.ipify.org?format=json");
    const data = await response.json();
    cachedIpAddress = data.ip; // Cache the IP address
    console.log("Fetched IP Address:", cachedIpAddress);
    return cachedIpAddress;
  } catch (error) {
    console.error("Error fetching IP address:", error);
    cachedIpAddress = "192.168.29.6"; // Fallback IP
    return cachedIpAddress;
  }
};
fetchIpAddress();

// Key generation function
const generateKey = () => {
  if (!cachedIpAddress) {
    throw new Error("IP address is not available. Make sure it is fetched before usage.");
  }
  
  const dynamicKey = CryptoJS.SHA256(cachedIpAddress).toString(CryptoJS.enc.Base64);
  return CryptoJS.SHA256(SECRET_KEY + dynamicKey).toString(CryptoJS.enc.Base64);
};

const ciperText = createTransform(
  // Inbound (state to be encrypted)
  (inboundState) => {
    try {
      const stringifiedState = JSON.stringify(inboundState);
      const combinedKey = generateKey(); // Use the centralized generateKey function
      return CryptoJS.AES.encrypt(stringifiedState, combinedKey).toString();
    } catch (error) {
      console.error("Error encrypting state:", error);
      return inboundState; // Return the original state in case of an error
    }
  },
  // Outbound (state to be decrypted)
  (outboundState) => {
    try {
      const combinedKey = generateKey(); // Use the centralized generateKey function
      const bytes = CryptoJS.AES.decrypt(outboundState, combinedKey);
      const decryptedState = bytes.toString(CryptoJS.enc.Utf8);
      return JSON.parse(decryptedState);
    } catch (error) {
      console.error("Error decrypting state:", error);
      return outboundState; // Return the original state in case of an error
    }
  }
);

// Fetch the IP address at the start and cache it


export default ciperText;






<div className="col-md-4">
                        <div className="form-floating form-floating-outline">
                          <input
                            className="form-control"
                            type="text"
                            id={`ID_${index}`}
                            {...register(` end_delay_days${index}`)}
                            placeholder="End Day"
                            style={{ borderRadius: "10px" }}
                          />
                          <label htmlFor={` end_delay_days${index}`}>
                            End Day
                          </label>
                        </div>
                      </div>









<div className="d-flex items-center border rounded-lg shadow-md p-4 space-x-3 w-100">
                {/* Container for Image Preview or Text Input */}
                <div className="flex-1 h-16">
                  {imagePreview ? (
                    <img
                      src={imagePreview}
                      alt="Uploaded"
                      className="h-full rounded border object-cover"
                    />
                  ) : (
                    <input
                      type="text"
                      className="h-full p-2 border-0 focus:outline-none focus:ring-0 w-75"
                      placeholder="Keep the conversation going..."
                      value={postContent}
                      onChange={(e) => setPostContent(e.target.value)}
                    />
                  )}
                </div>

                {/* Microphone Button */}
                <button
                  className={`p-2 border-none bg-transparent ${
                    isRecording ? "text-red-500" : "text-black"
                  }`}
                  onClick={toggleMicrophone}
                >
                  <KeyboardVoiceOutlinedIcon size={24} />
                </button>

                {/* Audio Playback (if recorded) */}
                {audioURL && (
                  <audio controls className="h-10">
                    <source src={audioURL} type="audio/wav" />
                    Your browser does not support the audio element.
                  </audio>
                )}

                {/* Emoji Picker Button */}
                <button
                  className="p-2 border-none bg-transparent"
                  onClick={handleEmojiButtonClick}
                >
                  <InsertEmoticonIcon size={24} />
                </button>

                {/* Emoji Picker */}
                {showEmojiPicker && (
                  <div
                    style={{
                      position: "absolute",
                      zIndex: 1000,
                      top: "50%",
                      left: "50%",
                      transform: "translate(-50%, -50%)",
                    }}
                  >
                    <EmojiPicker onEmojiClick={handleEmojiClick} />
                  </div>
                )}

                {/* File Upload Button */}
                <button
                  className="p-2 border-none bg-transparent"
                  onClick={handleButtonClick}
                >
                  <AttachFileIcon size={24} />
                  <input
                    type="file"
                    ref={fileInputRef}
                    className="d-none"
                    onChange={handleFileChange}
                  />
                </button>
              </div>


<td>
                          <Checkbox
                            checked={selectedRows.includes(data.enquiry_id)}
                            onChange={(event) =>
                              handleCheckboxChange(event, data.enquiry_id)
                            }
                          />
                          {index + 1}
                        </td>